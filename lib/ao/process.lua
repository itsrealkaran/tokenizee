users = users or {
    ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = {
      wallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      username = "itsrealkaran",
      displayName = "Karan Singh",
      bio = "Tokenizee | Kapsul",
      followers = {
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      createdAt = 1748131914411,
      following = {},
      dateOfBirth = "2004-06-01",
      posts = { "post-1709123456-1234" },
      bookmarkedPosts = { "post-1748284698500-2030", "post-1748278304747-9636" },
      comments = { "comment-1709123456-1111", "comment-1709123456-3333" }
    },
    ["8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg"] = {
      wallet = "8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg",
      username = "ankushkun",
      displayName = "Ankush Singh",
      bio = "BetterIdea",
      followers = {},
      createdAt = 1748131914415,
      following = {},
      dateOfBirth = "2004-06-15",
      posts = { "post-1709123456-5678" },
      bookmarkedPosts = { "post-1709123456-1234" },
      comments = { "comment-1709123456-2222" }
    },
    ["OVRxaP7mNWwjSihsr450Ah0zQwfd-LsMinVnhuapLFE"] = {
      wallet = "OVRxaP7mNWwjSihsr450Ah0zQwfd-LsMinVnhuapLFE",
      username = "ro_test3",
      displayName = "Rohit",
      bio = "Clickooor",
      followers = {},
      createdAt = 1748319368447,
      following = {},
      dateOfBirth = "2025-04-27",
      posts = { "post-1748319443108-2503" },
      bookmarkedPosts = {},
      comments = { "comment-1748319414889-1376" }
    },
    ["3ggyhyhQz68ug_rpNX3hHDZid_EPPjtu0ffuC6g9kL8"] = {
      wallet = "3ggyhyhQz68ug_rpNX3hHDZid_EPPjtu0ffuC6g9kL8",
      username = "nikoChan256",
      displayName = "nikoChan",
      bio = "not alive",
      followers = {},
      createdAt = 1748325943130,
      following = {},
      dateOfBirth = "2003-02-14",
      posts = { "post-1748326194790-8092" },
      bookmarkedPosts = {},
      comments = { "comment-1748326256169-1408" }
    },
    ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = {
      wallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      username = "itsalsokaran",
      displayName = "Karan Singh",
      bio = "Ardaas will heal everything!",
      followers = {
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      createdAt = 1748263558795,
      following = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      dateOfBirth = "2004-11-03",
      posts = { "post-1748263593361-1474", "post-1748263888299-9275" },
      bookmarkedPosts = { "post-1709123456-1234", "post-1748284698500-2030" },
      comments = { "comment-1748282514413-2130", "comment-1748312376309-1866", "comment-1748312339582-2244", "comment-1748312055996-7550" }
    },
    ["qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw"] = {
      wallet = "qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw",
      username = "ro_test",
      displayName = "Rohit",
      bio = "Opensourcerer",
      followers = {},
      createdAt = 1748284604702,
      following = {},
      dateOfBirth = "2025-05-25",
      posts = { "post-1748284698500-2030" },
      bookmarkedPosts = { "post-1748263888299-9275" },
      comments = { "comment-1748284640507-9218", "comment-1748319112199-2911", "comment-1748319075017-8483" }
    },
    ["WNtWM-CbP4p4__4KmnVrw_k7xUcT35kuVxuXu8BMvx4"] = {
      wallet = "WNtWM-CbP4p4__4KmnVrw_k7xUcT35kuVxuXu8BMvx4",
      username = "aykansal",
      displayName = "Ayush Kansal",
      bio = "directed to contribute to Web3 and XR",
      followers = {},
      createdAt = 1748278126742,
      following = {},
      dateOfBirth = "2004-02-28",
      posts = { "post-1748278304747-9636" },
      bookmarkedPosts = {},
      comments = {}
    },
    ["ww5nJTj6dD6Q6oIg-bOm20y2yawWDqDcQbQDcmwGOlI"] = {
      wallet = "ww5nJTj6dD6Q6oIg-bOm20y2yawWDqDcQbQDcmwGOlI",
      username = "asd",
      displayName = "asd",
      bio = "dsa",
      followers = {},
      createdAt = 1748278037487,
      following = {},
      dateOfBirth = "2006-07-21",
      posts = {},
      bookmarkedPosts = {},
      comments = {}
    },
    ["URgAA8eHJUtJ3198g8EjYrFimnU7zP3tzmrytgg19L8"] = {
      wallet = "URgAA8eHJUtJ3198g8EjYrFimnU7zP3tzmrytgg19L8",
      username = "shiv",
      displayName = "shivam kumar",
      bio = "hii",
      followers = {},
      createdAt = 1748282989194,
      following = {},
      dateOfBirth = "2003-10-25",
      posts = {},
      bookmarkedPosts = {},
      comments = {}
    }
}

posts = posts or {
    ["post-1709123456-5678"] = {
      id = "post-1709123456-5678",
      comments = { "comment-1709123456-3333" },
      upvotedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      downvotedBy = {
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      title = "Ankush Test",
      authorWallet = "8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg",
      content = "GMAO",
      topic = { "tech", "general" },
      sharedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      bookmarkedBy = {},
      createdAt = 1748263847196
    },
    ["post-1748263888299-9275"] = {
      id = "post-1748263888299-9275",
      comments = { "comment-1748282436760-8098", "comment-1748282514413-2130" },
      upvotedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      downvotedBy = {
        ["8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg"] = true,
        ["qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw"] = true
      },
      title = "Testing",
      authorWallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      content = "Cutieee",
      topic = { "art", "general" },
      sharedBy = {},
      bookmarkedBy = {
        ["qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw"] = true
      },
      createdAt = 1748263888299
    },
    ["post-1748326194790-8092"] = {
      id = "post-1748326194790-8092",
      comments = {},
      upvotedBy = {},
      downvotedBy = {},
      title = "yo yo yo r2-d2",
      authorWallet = "3ggyhyhQz68ug_rpNX3hHDZid_EPPjtu0ffuC6g9kL8",
      content = "r2-d2 lives ",
      topic = { "tech", "ai" },
      sharedBy = {},
      bookmarkedBy = {},
      createdAt = 1748326194790
    },
    ["post-1748278304747-9636"] = {
      id = "post-1748278304747-9636",
      comments = {},
      upvotedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      downvotedBy = {},
      title = "GM",
      authorWallet = "WNtWM-CbP4p4__4KmnVrw_k7xUcT35kuVxuXu8BMvx4",
      content = "gm gm",
      topic = { "web3", "general" },
      sharedBy = {},
      bookmarkedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      createdAt = 1748278304747
    },
    ["post-1709123456-1234"] = {
      id = "post-1709123456-1234",
      comments = { "comment-1709123456-1111", "comment-1709123456-2222", "comment-1748284640507-9218", "comment-1748312339582-2244", "comment-1748319075017-8483", "comment-1748326256169-1408" },
      upvotedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg"] = true
      },
      downvotedBy = {},
      title = "First Test Article",
      authorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      content = "Welcome to the network!",
      topic = { "general", "web3" },
      sharedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg"] = true
      },
      bookmarkedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      createdAt = 1748263847096
    },
    ["post-1748319443108-2503"] = {
      id = "post-1748319443108-2503",
      comments = {},
      upvotedBy = {},
      downvotedBy = {},
      title = "New Test Post",
      authorWallet = "OVRxaP7mNWwjSihsr450Ah0zQwfd-LsMinVnhuapLFE",
      content = "Some random text",
      topic = { "general" },
      sharedBy = {},
      bookmarkedBy = {},
      createdAt = 1748319443108
    },
    ["post-1748284698500-2030"] = {
      id = "post-1748284698500-2030",
      comments = { "comment-1748312055996-7550", "comment-1748312376309-1866", "comment-1748319112199-2911", "comment-1748319414889-1376" },
      upvotedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw"] = true
      },
      downvotedBy = {},
      title = "Vibe Coding with BetterIDEa",
      authorWallet = "qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw",
      content = "Test Post",
      topic = { "tech", "coding" },
      sharedBy = {},
      bookmarkedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      createdAt = 1748284698500
    }
}

comments = comments or {
    ["comment-1748326256169-1408"] = {
      authorWallet = "3ggyhyhQz68ug_rpNX3hHDZid_EPPjtu0ffuC6g9kL8",
      id = "comment-1748326256169-1408",
      postId = "post-1709123456-1234",
      content = "yokai",
      createdAt = 1748326256169
    },
    ["comment-1709123456-1111"] = {
      createdAt = 1748263847296,
      content = "This is a test comment",
      authorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1709123456-1111",
      postId = "post-1709123456-1234"
    },
    ["comment-1748312376309-1866"] = {
      authorWallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1748312376309-1866",
      postId = "post-1748284698500-2030",
      content = "And Vibe Check with Tokenizee ;)",
      createdAt = 1748312376309
    },
    ["comment-1709123456-2222"] = {
      createdAt = 1748263847346,
      content = "Great post!",
      authorWallet = "8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg",
      id = "comment-1709123456-2222",
      postId = "post-1709123456-1234"
    },
    ["comment-1748284640507-9218"] = {
      createdAt = 1748284640507,
      content = " made it work ",
      authorWallet = "qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw",
      id = "comment-1748284640507-9218",
      postId = "post-1709123456-1234"
    },
    ["comment-1748319414889-1376"] = {
      authorWallet = "OVRxaP7mNWwjSihsr450Ah0zQwfd-LsMinVnhuapLFE",
      id = "comment-1748319414889-1376",
      postId = "post-1748284698500-2030",
      content = "Looking great!",
      createdAt = 1748319414889
    },
    ["comment-1748282514413-2130"] = {
      createdAt = 1748282514413,
      content = " testing again ",
      authorWallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1748282514413-2130",
      postId = "post-1748263888299-9275"
    },
    ["comment-1709123456-3333"] = {
      createdAt = 1748263847396,
      content = "Nice one!",
      authorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1709123456-3333",
      postId = "post-1709123456-5678"
    },
    ["comment-1748319112199-2911"] = {
      authorWallet = "qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw",
      id = "comment-1748319112199-2911",
      postId = "post-1748284698500-2030",
      content = "tACK",
      createdAt = 1748319112199
    },
    ["comment-1748319075017-8483"] = {
      authorWallet = "qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw",
      id = "comment-1748319075017-8483",
      postId = "post-1709123456-1234",
      content = "This article looks great!",
      createdAt = 1748319075017
    },
    ["comment-1748312339582-2244"] = {
      authorWallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1748312339582-2244",
      postId = "post-1709123456-1234",
      content = "test",
      createdAt = 1748312339582
    },
    ["comment-1748312055996-7550"] = {
      createdAt = 1748312055996,
      content = "mobile test",
      authorWallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1748312055996-7550",
      postId = "post-1748284698500-2030"
    }
}

-- Initialize notifications table
notifications = notifications or {}

-- Add notification types
local NOTIFICATION_TYPES = {
    FOLLOW = "follow",
    COMMENT = "comment",
    UPVOTE = "upvote",
    DOWNVOTE = "downvote",
    SHARE = "share",
    MENTION = "mention"
}

local function generateId(prefix)
    local timestamp = os.time()
    local random = math.random(1000, 9999)
    return string.format("%s-%d-%d", prefix, timestamp, random)
end

local json = require("json")

-- Add logging function at the top
local function log(level, message, data)
    local timestamp = os.date("%Y-%m-%d %H:%M:%S")
    local logMessage = string.format("[%s] [%s] %s", timestamp, level, message)
    if data then
        logMessage = logMessage .. " Data: " .. json.encode(data)
    end
    print(logMessage)
end

-- Utility Functions
local function countTableEntries(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end

local function countArrayEntries(arr)
    local count = 0
    for _ in ipairs(arr) do
        count = count + 1
    end
    return count
end

local function getAuthorDetails(wallet)
    if not users[wallet] then
        return nil
    end
    return {
        username = users[wallet].username,
        displayName = users[wallet].displayName
    }
end

local function formatPostResponse(post, requestingWallet)
    if not post then return nil end
    
    local author = getAuthorDetails(post.authorWallet)
    if not author then return nil end

    return {
        id = post.id,
        title = post.title,
        content = post.content,
        topic = post.topic,
        author = {
            wallet = post.authorWallet,
            username = author.username,
            displayName = author.displayName
        },
        createdAt = post.createdAt,
        comments = post.comments,
        upvotes = countTableEntries(post.upvotedBy),
        downvotes = countTableEntries(post.downvotedBy),
        shares = countTableEntries(post.sharedBy),
        bookmarks = countTableEntries(post.bookmarkedBy),
        hasUpvoted = post.upvotedBy[requestingWallet] == true,
        hasDownvoted = post.downvotedBy[requestingWallet] == true,
        hasShared = post.sharedBy[requestingWallet] == true,
        hasBookmarked = post.bookmarkedBy[requestingWallet] == true
    }
end

local function formatUserResponse(user, requestingWallet)
    if not user then return nil end

    return {
        wallet = user.wallet,
        username = user.username,
        displayName = user.displayName,
        bio = user.bio,
        dateOfBirth = user.dateOfBirth,
        createdAt = user.createdAt,
        followers = countTableEntries(user.followers),
        following = countTableEntries(user.following),
        posts = countArrayEntries(user.posts),
        comments = countArrayEntries(user.comments),
        isFollowing = user.followers[requestingWallet] == true
    }
end

local function formatFollowUserResponse(follower, following, requestingWallet)
    if not follower or not following then return nil end

    return {
        follower = formatUserResponse(follower, requestingWallet),
        following = formatUserResponse(following, requestingWallet)
    }
end


-- Add notification creation function
local function createNotification(recipientWallet, type, actorWallet, postId, data)
    if not notifications[recipientWallet] then
        notifications[recipientWallet] = {
            items = {},
            lastRead = os.time()
        }
    end

    local notificationId = generateId("notification")
    local notification = {
        id = notificationId,
        type = type,
        actorWallet = actorWallet,
        postId = postId,
        data = data,
        createdAt = os.time(),
        read = false
    }

    table.insert(notifications[recipientWallet].items, notification)
    return notification
end

Handlers.add("Register", { Action = "Register" }, function(msg)
    log("INFO", "Register request received", {
        username = msg.Tags["Username"],
        displayName = msg.Tags["DisplayName"],
        wallet = msg.Tags["Wallet"]
    })

    local username = msg.Tags["Username"]
    local displayName = msg.Tags["DisplayName"]
    local dateOfBirth = msg.Tags["DateOfBirth"]
    local bio = msg.Tags["Bio"]
    local wallet = msg.Tags["Wallet"]

    if users[wallet] then
        log("ERROR", "Register failed - Wallet already exists", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "RegisterResponse", Status = "Error" },
            Data = json.encode({ error = "Wallet already exists." })
        })
        return
    end

    for _, user in pairs(users) do
        if user.username == username then
            log("ERROR", "Register failed - Username already exists", { username = username })
            ao.send({
                Target = msg.From,
                Tags = { Action = "RegisterResponse", Status = "Error" },
                Data = json.encode({ error = "Username already exists." })
            })
            return
        end
    end

    if not username or not displayName then
        log("ERROR", "Register failed - Missing required fields", { 
            username = username, 
            displayName = displayName 
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "RegisterResponse", Status = "Error" },
            Data = json.encode({ error = "Missing required fields." })
        })
        return
    end

    local timestamp = os.time()
    users[wallet] = {
        wallet = wallet,
        username = username,
        displayName = displayName,
        dateOfBirth = dateOfBirth,
        bio = bio,
        posts = {},
        bookmarkedPosts = {},
        comments = {},
        followers = {},
        following = {},
        createdAt = timestamp
    }

    log("INFO", "User registered successfully", { 
        username = username,
        wallet = wallet
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "RegisterResponse", Status = "Success" },
        Data = json.encode({ 
            message = "User registered successfully.",
            user = formatUserResponse(users[wallet], wallet)
        })
    })
end)

--update user
Handlers.add("UpdateUser", { Action = "UpdateUser" }, function(msg)
    log("INFO", "Update user request received", {
        wallet = msg.Tags["Wallet"],
        newUsername = msg.Tags["NewUsername"]
    })

    local wallet = msg.Tags["Wallet"]
    local newUsername = msg.Tags["NewUsername"]
    local displayName = msg.Tags["DisplayName"]
    local dateOfBirth = msg.Tags["DateOfBirth"]
    local bio = msg.Tags["Bio"]

    if not users[wallet] then
        log("ERROR", "Update failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "UpdateUserResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    if newUsername ~= users[wallet].username then
        for _, user in pairs(users) do
            if user.username == newUsername then
                log("ERROR", "Update failed - New username already exists", { 
                    newUsername = newUsername 
                })
                ao.send({
                    Target = msg.From,
                    Tags = { Action = "UpdateUserResponse", Status = "Error" },
                    Data = json.encode({ error = "New username already exists." })
                })
                return
            end
        end
    end

    users[wallet].username = newUsername
    users[wallet].displayName = displayName
    users[wallet].dateOfBirth = dateOfBirth
    users[wallet].bio = bio

    log("INFO", "User updated successfully", { 
        wallet = wallet,
        newUsername = newUsername
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "UpdateUserResponse", Status = "Success" },
        Data = json.encode({ 
            message = "User updated successfully.", 
            user = formatUserResponse(users[wallet], wallet)
        })
    })
end)

Handlers.add("CreatePost", { Action = "CreatePost" }, function(msg)
    log("INFO", "Create post request received", {
        wallet = msg.Tags["Wallet"],
        title = msg.Tags["Title"]
    })
    
    local wallet = msg.Tags["Wallet"]
    
    if not users[wallet] then
        log("ERROR", "Create post failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CreatePostResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    local title = msg.Tags["Title"]
    local content = msg.Tags["Content"]
    local topic = msg.Tags["Topic"]

    if not title or not content then
        log("ERROR", "Create post failed - Invalid post format", { 
            title = title, 
            content = content 
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CreatePostResponse", Status = "Error" },
            Data = json.encode({ error = "Invalid post format. Expected 'title: content'" })
        })
        return
    end

    local postId = generateId("post")
    local timestamp = os.time()

    posts[postId] = {
        id = postId,
        authorWallet = wallet,
        title = title,
        content = content,
        topic = topic,
        upvotedBy = {},
        downvotedBy = {},
        sharedBy = {},
        bookmarkedBy = {},
        createdAt = timestamp,
        comments = {}
    }

    table.insert(users[wallet].posts, postId)

    log("INFO", "Post created successfully", { 
        postId = postId,
        wallet = wallet
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "CreatePostResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Post created successfully.",
            postId = postId,
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

Handlers.add("LoadComments", { Action = "LoadComments" }, function(msg)
    local postId = msg.Tags["PostId"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not postId then
        ao.send({
            Target = msg.From,
            Tags = { Action = "LoadCommentsResponse", Status = "Error" },
            Data = json.encode({ error = "Missing PostId tag." })
        })
        return
    end

    if not posts[postId] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "LoadCommentsResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    local commentIds = posts[postId].comments
    local commentData = {}
    
    for _, commentId in ipairs(commentIds) do
        if comments[commentId] then
            local comment = comments[commentId]
            local author = getAuthorDetails(comment.authorWallet)
            if author then
                local formattedComment = {
                    id = comment.id,
                    postId = comment.postId,
                    content = comment.content,
                    author = {
                        wallet = comment.authorWallet,
                        username = author.username,
                        displayName = author.displayName
                    },
                    createdAt = comment.createdAt,
                    postTitle = posts[postId].title
                }
                table.insert(commentData, formattedComment)
            end
        end
    end

    -- Sort comments by creation time (newest first)
    table.sort(commentData, function(a, b)
        return a.createdAt > b.createdAt
    end)
    
    ao.send({
        Target = msg.From,
        Tags = { Action = "LoadCommentsResponse", Status = "Success" },
        Data = json.encode({ comments = commentData })
    })
end)

Handlers.add("GetFeed", { Action = "GetFeed" }, function(msg)
    local requestingWallet = msg.Tags["RequestingWallet"]
    local feed = {}

    for postId, post in pairs(posts) do
        table.insert(feed, formatPostResponse(post, requestingWallet))
    end

    -- Sort posts by creation time (newest first)
    table.sort(feed, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetFeedResponse", Status = "Success" },
        Data = json.encode({ posts = feed })
    })
end)

Handlers.add("GetTrending", { Action = "GetTrending" }, function(msg)
    local requestingWallet = msg.Tags["RequestingWallet"]
    local trending = {}

    for postId, post in pairs(posts) do
        local netScore = countArrayEntries(post.upvotedBy) - countArrayEntries(post.downvotedBy)
        local formattedPost = formatPostResponse(post, requestingWallet)
        formattedPost.netScore = netScore
        table.insert(trending, formattedPost)
    end

    -- Sort posts by net score (highest first)
    table.sort(trending, function(a, b)
        return a.netScore > b.netScore
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetTrendingResponse", Status = "Success" },
        Data = json.encode({ posts = trending })
    })
end)

Handlers.add("GetLeaderboard", { Action = "GetLeaderboard" }, function(msg)
    local requestingWallet = msg.Tags["RequestingWallet"]
    local leaderboard = {}

    for wallet, user in pairs(users) do
        local score = countArrayEntries(user.posts) + countArrayEntries(user.comments)
        table.insert(leaderboard, {
            user = formatUserResponse(user, requestingWallet),
            score = score
        })
    end

    table.sort(leaderboard, function(a, b)
        return a.score > b.score
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetLeaderboardResponse", Status = "Success" },
        Data = json.encode({ users = leaderboard })
    })
end)

Handlers.add("GetUserPosts", { Action = "GetUserPosts" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local requestingWallet = msg.Tags["RequestingWallet"]

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetUserPostsResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    local userPosts = {}
    for _, postId in ipairs(users[wallet].posts) do
        if posts[postId] then
            table.insert(userPosts, formatPostResponse(posts[postId], requestingWallet))
        end
    end

    table.sort(userPosts, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetUserPostsResponse", Status = "Success" },
        Data = json.encode({ posts = userPosts })
    })
end)

Handlers.add("GetUserComments", { Action = "GetUserComments" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetUserCommentsResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetUserCommentsResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    local userComments = {}
    for _, commentId in ipairs(users[wallet].comments) do
        if comments[commentId] then
            local comment = comments[commentId]
            local post = posts[comment.postId]
            if post then
                local author = getAuthorDetails(comment.authorWallet)
                if author then
                    local formattedComment = {
                        id = comment.id,
                        postId = comment.postId,
                        content = comment.content,
                        author = {
                            wallet = comment.authorWallet,
                            username = author.username,
                            displayName = author.displayName
                        },
                        createdAt = comment.createdAt,
                        postTitle = post.title
                    }
                    table.insert(userComments, formattedComment)
                end
            end
        end
    end

    -- Sort comments by creation time (newest first)
    table.sort(userComments, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetUserCommentsResponse", Status = "Success" },
        Data = json.encode({ comments = userComments })
    })
end)

Handlers.add("BookmarkPost", { Action = "BookmarkPost" }, function(msg)
    log("INFO", "Bookmark post request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"],
        action = msg.Tags["BookmarkAction"]
    })

    local wallet = msg.Tags["Wallet"]
    local postId = msg.Tags["PostId"]
    local action = msg.Tags["BookmarkAction"]
    
    if not users[wallet] then
        log("ERROR", "Bookmark failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "BookmarkPostResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    if not posts[postId] then
        log("ERROR", "Bookmark failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "BookmarkPostResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if action == "add" then
        if posts[postId].bookmarkedBy[wallet] then
            log("ERROR", "Bookmark failed - Post already bookmarked", { 
                wallet = wallet,
                postId = postId 
            })
            ao.send({
                Target = msg.From,
                Tags = { Action = "BookmarkPostResponse", Status = "Error" },
                Data = json.encode({ error = "Post already bookmarked." })
            })
            return
        end
        
        posts[postId].bookmarkedBy[wallet] = true
        table.insert(users[wallet].bookmarkedPosts, postId)
        log("INFO", "Post bookmarked successfully", {
            wallet = wallet,
            postId = postId
        })
    elseif action == "remove" then
        posts[postId].bookmarkedBy[wallet] = nil
        for i, id in ipairs(users[wallet].bookmarkedPosts) do
            if id == postId then
                table.remove(users[wallet].bookmarkedPosts, i)
                break
            end
        end
        log("INFO", "Post bookmark removed successfully", {
            wallet = wallet,
            postId = postId
        })
    else
        log("ERROR", "Bookmark failed - Invalid action", { 
            action = action,
            wallet = wallet,
            postId = postId 
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "BookmarkPostResponse", Status = "Error" },
            Data = json.encode({ error = "Invalid action. Use 'add' or 'remove'." })
        })
        return
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "BookmarkPostResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Bookmark updated successfully.",
            bookmarkedPosts = users[wallet].bookmarkedPosts,
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

Handlers.add("GetPersonalizedFeed", { Action = "GetPersonalizedFeed" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetPersonalizedFeedResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetPersonalizedFeedResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    local feed = {}
    local user = users[wallet]

    -- Get posts from followed users
    for following, _ in pairs(user.following) do
        if users[following] then
            for _, postId in ipairs(users[following].posts) do
                if posts[postId] then
                    table.insert(feed, formatPostResponse(posts[postId], requestingWallet))
                end
            end
        end
    end

    -- Add user's own posts
    for _, postId in ipairs(user.posts) do
        if posts[postId] then
            table.insert(feed, formatPostResponse(posts[postId], requestingWallet))
        end
    end

    -- Sort posts by creation time (newest first)
    table.sort(feed, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetPersonalizedFeedResponse", Status = "Success" },
        Data = json.encode({ posts = feed })
    })
end)

Handlers.add("GetBookmarkedFeed", { Action = "GetBookmarkedFeed" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetBookmarkedFeedResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetBookmarkedFeedResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    local feed = {}
    local user = users[wallet]

    for _, postId in ipairs(user.bookmarkedPosts) do
        if posts[postId] then
            table.insert(feed, formatPostResponse(posts[postId], requestingWallet))
        end
    end

    -- Sort posts by creation time (newest first)
    table.sort(feed, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetBookmarkedFeedResponse", Status = "Success" },
        Data = json.encode({ posts = feed })
    })
end)

Handlers.add("GetTopicFeed", { Action = "GetTopicFeed" }, function(msg)
    local topic = msg.Tags["Topic"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not topic then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetTopicFeedResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Topic tag." })
        })
        return
    end

    local feed = {}

    for _, post in pairs(posts) do
        if post.topic == topic then
            table.insert(feed, formatPostResponse(post, requestingWallet))
        end
    end

    -- Sort posts by creation time (newest first)
    table.sort(feed, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetTopicFeedResponse", Status = "Success" },
        Data = json.encode({ posts = feed })
    })
end)

-- Add notification handler
Handlers.add("GetNotifications", { Action = "GetNotifications" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetNotificationsResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetNotificationsResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    -- Initialize notifications for user if not exists
    notifications[wallet] = notifications[wallet] or {
        items = {},
        lastRead = os.time()
    }

    -- Format notifications with user details
    local formattedNotifications = {}
    for _, notification in ipairs(notifications[wallet].items) do
        local formattedNotification = {
            id = notification.id,
            type = notification.type,
            createdAt = notification.createdAt,
            read = notification.read,
            data = notification.data
        }

        -- Add user details for actor
        if notification.actorWallet and users[notification.actorWallet] then
            formattedNotification.actor = formatUserResponse(users[notification.actorWallet], wallet)
        end

        -- Add post details if applicable
        if notification.postId and posts[notification.postId] then
            formattedNotification.post = formatPostResponse(posts[notification.postId], wallet)
        end

        table.insert(formattedNotifications, formattedNotification)
    end

    -- Sort notifications by creation time (newest first)
    table.sort(formattedNotifications, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetNotificationsResponse", Status = "Success" },
        Data = json.encode({
            notifications = formattedNotifications,
            unreadCount = #formattedNotifications - notifications[wallet].lastRead
        })
    })
end)

-- Add mark notifications as read handler
Handlers.add("MarkNotificationsRead", { Action = "MarkNotificationsRead" }, function(msg)
    log("INFO", "Mark notifications read request received", {
        wallet = msg.Tags["Wallet"]
    })

    local wallet = msg.Tags["Wallet"]
    
    if not wallet then
        log("ERROR", "Mark notifications read failed - Missing wallet", {})
        ao.send({
            Target = msg.From,
            Tags = { Action = "MarkNotificationsReadResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        log("ERROR", "Mark notifications read failed - User does not exist", { 
            wallet = wallet 
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "MarkNotificationsReadResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    -- Initialize notifications for user if not exists
    notifications[wallet] = notifications[wallet] or {
        items = {},
        lastRead = os.time()
    }

    -- Mark all notifications as read
    for _, notification in ipairs(notifications[wallet].items) do
        notification.read = true
    end
    notifications[wallet].lastRead = os.time()

    log("INFO", "Notifications marked as read", {
        wallet = wallet,
        count = #notifications[wallet].items
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "MarkNotificationsReadResponse", Status = "Success" },
        Data = json.encode({ message = "Notifications marked as read." })
    })
end)

-- Update FollowUser handler
Handlers.add("FollowUser", { Action = "FollowUser" }, function(msg)
    log("INFO", "Follow user request received", {
        followerWallet = msg.Tags["FollowerWallet"],
        followingWallet = msg.Tags["FollowingWallet"]
    })

    local followerWallet = msg.Tags["FollowerWallet"]
    local followingWallet = msg.Tags["FollowingWallet"]

    if not users[followerWallet] or not users[followingWallet] then
        log("ERROR", "Follow failed - User does not exist", { 
            followerWallet = followerWallet,
            followingWallet = followingWallet
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "FollowUserResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    users[followerWallet].following[followingWallet] = true
    users[followingWallet].followers[followerWallet] = true

    log("INFO", "User followed successfully", {
        followerWallet = followerWallet,
        followingWallet = followingWallet
    })

    createNotification(
        followingWallet,
        NOTIFICATION_TYPES.FOLLOW,
        followerWallet,
        nil,
        { message = "started following you" }
    )
    log("INFO", "Follow notification created", {
        recipient = followingWallet,
        actor = followerWallet
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "FollowUserResponse", Status = "Success" },
        Data = json.encode({ 
            message = "User followed successfully.",
            result = formatFollowUserResponse(users[followerWallet], users[followingWallet], followerWallet)
        })
    })
end)

-- Update CommentPost handler
Handlers.add("CommentPost", { Action = "CommentPost" }, function(msg)
    log("INFO", "Comment post request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"],
        content = msg.Tags["Content"]
    })

    local postId = msg.Tags["PostId"]
    local wallet = msg.Tags["Wallet"]
    local content = msg.Tags["Content"]
    
    if not users[wallet] then
        log("ERROR", "Comment failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CommentPostResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    if not posts[postId] then
        log("ERROR", "Comment failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CommentPostResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if not content or content == "" then
        log("ERROR", "Comment failed - Empty content", { 
            wallet = wallet,
            postId = postId 
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CommentPostResponse", Status = "Error" },
            Data = json.encode({ error = "Comment content cannot be empty." })
        })
        return
    end

    local commentId = generateId("comment")
    local timestamp = os.time()

    comments[commentId] = {
        id = commentId,
        authorWallet = wallet,
        content = content,
        createdAt = timestamp,
        postId = postId
    }

    table.insert(posts[postId].comments, commentId)
    table.insert(users[wallet].comments, commentId)

    log("INFO", "Comment posted successfully", {
        commentId = commentId,
        wallet = wallet,
        postId = postId
    })

    if posts[postId].authorWallet ~= wallet then
        createNotification(
            posts[postId].authorWallet,
            NOTIFICATION_TYPES.COMMENT,
            wallet,
            postId,
            { message = "commented on your post" }
        )
        log("INFO", "Comment notification created", {
            recipient = posts[postId].authorWallet,
            actor = wallet,
            postId = postId
        })
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "CommentPostResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Comment posted successfully.",
            commentId = commentId,
            comment = formatCommentResponse(comments[commentId], wallet)
        })
    })
end)

-- Update UpvotePost handler
Handlers.add("UpvotePost", { Action = "Upvote" }, function(msg)
    log("INFO", "Upvote post request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"]
    })

    local postId = msg.Tags["PostId"]
    local wallet = msg.Tags["Wallet"]

    if not posts[postId] then
        log("ERROR", "Upvote failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "UpvoteResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if not users[wallet] then
        log("ERROR", "Upvote failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "UpvoteResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    posts[postId].downvotedBy[wallet] = nil
    posts[postId].upvotedBy[wallet] = true

    log("INFO", "Post upvoted successfully", {
        wallet = wallet,
        postId = postId
    })

    if posts[postId].authorWallet ~= wallet then
        createNotification(
            posts[postId].authorWallet,
            NOTIFICATION_TYPES.UPVOTE,
            wallet,
            postId,
            { message = "upvoted your post" }
        )
        log("INFO", "Upvote notification created", {
            recipient = posts[postId].authorWallet,
            actor = wallet,
            postId = postId
        })
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "UpvoteResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Post upvoted successfully.",
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

-- Update DownvotePost handler
Handlers.add("DownvotePost", { Action = "Downvote" }, function(msg)
    log("INFO", "Downvote post request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"]
    })

    local postId = msg.Tags["PostId"]
    local wallet = msg.Tags["Wallet"]

    if not posts[postId] then
        log("ERROR", "Downvote failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "DownvoteResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if not users[wallet] then
        log("ERROR", "Downvote failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "DownvoteResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    posts[postId].upvotedBy[wallet] = nil
    posts[postId].downvotedBy[wallet] = true

    log("INFO", "Post downvoted successfully", {
        wallet = wallet,
        postId = postId
    })

    if posts[postId].authorWallet ~= wallet then
        createNotification(
            posts[postId].authorWallet,
            NOTIFICATION_TYPES.DOWNVOTE,
            wallet,
            postId,
            { message = "downvoted your post" }
        )
        log("INFO", "Downvote notification created", {
            recipient = posts[postId].authorWallet,
            actor = wallet,
            postId = postId
        })
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "DownvoteResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Post downvoted successfully.",
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

-- Update SharePost handler
Handlers.add("SharePost", { Action = "SharePost" }, function(msg)
    log("INFO", "Share post request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"]
    })

    local postId = msg.Tags["PostId"]
    local wallet = msg.Tags["Wallet"]

    if not posts[postId] then
        log("ERROR", "Share failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "SharePostResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if not users[wallet] then
        log("ERROR", "Share failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "SharePostResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    posts[postId].sharedBy[wallet] = true

    log("INFO", "Post shared successfully", {
        wallet = wallet,
        postId = postId
    })

    if posts[postId].authorWallet ~= wallet then
        createNotification(
            posts[postId].authorWallet,
            NOTIFICATION_TYPES.SHARE,
            wallet,
            postId,
            { message = "shared your post" }
        )
        log("INFO", "Share notification created", {
            recipient = posts[postId].authorWallet,
            actor = wallet,
            postId = postId
        })
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "SharePostResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Post shared successfully.",
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

Handlers.add("GetPostStats", { Action = "GetPostStats" }, function(msg)
    local postId = msg.Tags["PostId"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not postId then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetPostStatsResponse", Status = "Error" },
            Data = json.encode({ error = "Missing PostId tag." })
        })
        return
    end

    if not posts[postId] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetPostStatsResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    local post = posts[postId]
    local stats = {
        post = formatPostResponse(post, requestingWallet),
        engagement = {
            upvotes = countTableEntries(post.upvotedBy),
            downvotes = countTableEntries(post.downvotedBy),
            shares = countTableEntries(post.sharedBy),
            bookmarks = countTableEntries(post.bookmarkedBy),
            comments = countArrayEntries(post.comments)
        },
        recentActivity = {
            comments = {},
            upvoters = {},
            downvoters = {},
            sharers = {},
            bookmarkers = {}
        }
    }

    -- Get recent comments with author details
    local recentComments = {}
    for _, commentId in ipairs(post.comments) do
        if comments[commentId] then
            table.insert(recentComments, formatCommentResponse(comments[commentId], requestingWallet))
        end
    end
    table.sort(recentComments, function(a, b) return a.createdAt > b.createdAt end)
    for i = 1, math.min(5, #recentComments) do
        table.insert(stats.recentActivity.comments, recentComments[i])
    end

    -- Get recent upvoters
    local upvoters = {}
    for wallet, _ in pairs(post.upvotedBy) do
        if users[wallet] then
            table.insert(upvoters, formatUserResponse(users[wallet], requestingWallet))
        end
    end
    for i = 1, math.min(5, #upvoters) do
        table.insert(stats.recentActivity.upvoters, upvoters[i])
    end

    -- Get recent downvoters
    local downvoters = {}
    for wallet, _ in pairs(post.downvotedBy) do
        if users[wallet] then
            table.insert(downvoters, formatUserResponse(users[wallet], requestingWallet))
        end
    end
    for i = 1, math.min(5, #downvoters) do
        table.insert(stats.recentActivity.downvoters, downvoters[i])
    end

    -- Get recent sharers
    local sharers = {}
    for wallet, _ in pairs(post.sharedBy) do
        if users[wallet] then
            table.insert(sharers, formatUserResponse(users[wallet], requestingWallet))
        end
    end
    for i = 1, math.min(5, #sharers) do
        table.insert(stats.recentActivity.sharers, sharers[i])
    end

    -- Get recent bookmarkers
    local bookmarkers = {}
    for wallet, _ in pairs(post.bookmarkedBy) do
        if users[wallet] then
            table.insert(bookmarkers, formatUserResponse(users[wallet], requestingWallet))
        end
    end
    for i = 1, math.min(5, #bookmarkers) do
        table.insert(stats.recentActivity.bookmarkers, bookmarkers[i])
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetPostStatsResponse", Status = "Success" },
        Data = json.encode(stats)
    })
end)

-- Add GetUser handler
Handlers.add("GetUser", { Action = "GetUser" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local username = msg.Tags["Username"]
    local requestingWallet = msg.Tags["RequestingWallet"] or wallet

    if not wallet and not username then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetUserResponse", Status = "Error" },
            Data = json.encode({ error = "Either Wallet or Username must be provided." })
        })
        return
    end

    local user = nil
    if wallet then
        user = users[wallet]
    else
        -- Search by username
        for _, u in pairs(users) do
            if u.username == username then
                user = u
                break
            end
        end
    end

    if not user then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetUserResponse", Status = "Error" },
            Data = json.encode({ error = "User not found." })
        })
        return
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetUserResponse", Status = "Success" },
        Data = json.encode({ user = formatUserResponse(user, requestingWallet) })
    })
end)

-- Add GetFollowersList handler
Handlers.add("GetFollowersList", { Action = "GetFollowersList" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetFollowersListResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetFollowersListResponse", Status = "Error" },
            Data = json.encode({ error = "User not found." })
        })
        return
    end

    -- Get followers list
    local followersList = {}
    for followerWallet, _ in pairs(users[wallet].followers) do
        if users[followerWallet] then
            table.insert(followersList, formatUserResponse(users[followerWallet], requestingWallet))
        end
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetFollowersListResponse", Status = "Success" },
        Data = json.encode({ users = followersList })
    })
end)

-- Add GetFollowingList handler
Handlers.add("GetFollowingList", { Action = "GetFollowingList" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetFollowingListResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetFollowingListResponse", Status = "Error" },
            Data = json.encode({ error = "User not found." })
        })
        return
    end

    -- Get following list
    local followingList = {}
    for followingWallet, _ in pairs(users[wallet].following) do
        if users[followingWallet] then
            table.insert(followingList, formatUserResponse(users[followingWallet], requestingWallet))
        end
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetFollowingListResponse", Status = "Success" },
        Data = json.encode({ users = followingList })
    })
end)