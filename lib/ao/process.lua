users = users or {
    ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = {
      wallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      username = "itsrealkaran",
      displayName = "Karan Singh",
      bio = "Tokenizee | Kapsul",
      profileImageUrl = "https://pbs.twimg.com/profile_images/1929278179690070016/4JSCRDvp_400x400.jpg",
      backgroundImageUrl = "https://pbs.twimg.com/profile_banners/1420367124124487680/1725384277/1500x500",
      followers = {
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      createdAt = 1748131914411,
      following = {},
      dateOfBirth = "2004-06-01",
      posts = { "post-1709123456-1234" },
      bookmarkedPosts = { "post-1748284698500-2030", "post-1748278304747-9636" },
      comments = { "comment-1709123456-1111", "comment-1709123456-3333" }
    },
    ["8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg"] = {
      wallet = "8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg",
      username = "ankushkun",
      displayName = "Ankush Singh",
      bio = "BetterIdea",
      followers = {},
      createdAt = 1748131914415,
      following = {},
      dateOfBirth = "2004-06-15",
      posts = { "post-1709123456-5678" },
      bookmarkedPosts = { "post-1709123456-1234" },
      comments = { "comment-1709123456-2222" }
    },
    ["OVRxaP7mNWwjSihsr450Ah0zQwfd-LsMinVnhuapLFE"] = {
      wallet = "OVRxaP7mNWwjSihsr450Ah0zQwfd-LsMinVnhuapLFE",
      username = "ro_test3",
      displayName = "Rohit",
      bio = "Clickooor",
      followers = {},
      createdAt = 1748319368447,
      following = {},
      dateOfBirth = "2025-04-27",
      posts = { "post-1748319443108-2503" },
      bookmarkedPosts = {},
      comments = { "comment-1748319414889-1376" }
    },
    ["3ggyhyhQz68ug_rpNX3hHDZid_EPPjtu0ffuC6g9kL8"] = {
      wallet = "3ggyhyhQz68ug_rpNX3hHDZid_EPPjtu0ffuC6g9kL8",
      username = "nikoChan256",
      displayName = "nikoChan",
      bio = "not alive",
      followers = {},
      createdAt = 1748325943130,
      following = {},
      dateOfBirth = "2003-02-14",
      posts = { "post-1748326194790-8092" },
      bookmarkedPosts = {},
      comments = { "comment-1748326256169-1408" }
    },
    ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = {
      wallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      username = "itsalsokaran",
      displayName = "Karan Singh",
      bio = "Ardaas will heal everything!",
      followers = {
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      createdAt = 1748263558795,
      following = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      dateOfBirth = "2004-11-03",
      posts = { "post-1748263593361-1474", "post-1748263888299-9275" },
      bookmarkedPosts = { "post-1709123456-1234", "post-1748284698500-2030" },
      comments = { "comment-1748282514413-2130", "comment-1748312376309-1866", "comment-1748312339582-2244", "comment-1748312055996-7550" }
    },
    ["qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw"] = {
      wallet = "qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw",
      username = "ro_test",
      displayName = "Rohit",
      bio = "Opensourcerer",
      followers = {},
      createdAt = 1748284604702,
      following = {},
      dateOfBirth = "2025-05-25",
      posts = { "post-1748284698500-2030" },
      bookmarkedPosts = { "post-1748263888299-9275" },
      comments = { "comment-1748284640507-9218", "comment-1748319112199-2911", "comment-1748319075017-8483" }
    },
    ["WNtWM-CbP4p4__4KmnVrw_k7xUcT35kuVxuXu8BMvx4"] = {
      wallet = "WNtWM-CbP4p4__4KmnVrw_k7xUcT35kuVxuXu8BMvx4",
      username = "aykansal",
      displayName = "Ayush Kansal",
      bio = "directed to contribute to Web3 and XR",
      followers = {},
      createdAt = 1748278126742,
      following = {},
      dateOfBirth = "2004-02-28",
      posts = { "post-1748278304747-9636" },
      bookmarkedPosts = {},
      comments = {}
    },
    ["ww5nJTj6dD6Q6oIg-bOm20y2yawWDqDcQbQDcmwGOlI"] = {
      wallet = "ww5nJTj6dD6Q6oIg-bOm20y2yawWDqDcQbQDcmwGOlI",
      username = "asd",
      displayName = "asd",
      bio = "dsa",
      followers = {},
      createdAt = 1748278037487,
      following = {},
      dateOfBirth = "2006-07-21",
      posts = {},
      bookmarkedPosts = {},
      comments = {}
    },
    ["URgAA8eHJUtJ3198g8EjYrFimnU7zP3tzmrytgg19L8"] = {
      wallet = "URgAA8eHJUtJ3198g8EjYrFimnU7zP3tzmrytgg19L8",
      username = "shiv",
      displayName = "shivam kumar",
      bio = "hii",
      followers = {},
      createdAt = 1748282989194,
      following = {},
      dateOfBirth = "2003-10-25",
      posts = {},
      bookmarkedPosts = {},
      comments = {}
    }
}

posts = posts or {
    ["post-1709123456-5678"] = {
      id = "post-1709123456-5678",
      comments = { "comment-1709123456-3333" },
      upvotedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      downvotedBy = {
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      title = "Ankush Test",
      authorWallet = "8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg",
      content = "Technology is evolving at a rapid pace, transforming the way we live, work, and interact. From artificial intelligence to blockchain, the innovations of today are shaping the world of tomorrow. In this post, we explore the latest trends in tech and how they are impacting our daily lives. Whether you're a developer, entrepreneur, or enthusiast, staying updated with these advancements is crucial for success in the digital age.",
      topic = { "tech", "general" },
      media = {
        {
          url = "https://example.com/image1.jpg",
          alt = "Technology innovation",
          type = "image"
        },
        {
          url = "https://example.com/video1.mp4",
          alt = "Tech demo video",
          type = "video"
        }
      },
      sharedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      bookmarkedBy = {},
      createdAt = 1748263847196
    },
    ["post-1748263888299-9275"] = {
      id = "post-1748263888299-9275",
      comments = { "comment-1748282436760-8098", "comment-1748282514413-2130" },
      upvotedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      downvotedBy = {
        ["8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg"] = true,
        ["qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw"] = true
      },
      title = "Testing",
      authorWallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      content = "Art is not just a form of expression, but a window into the soul of humanity. Throughout history, artists have used their craft to challenge norms, inspire change, and evoke emotion. In this article, we delve into the world of art, exploring its evolution from classical masterpieces to contemporary works. Discover how art continues to influence culture and society in profound ways.",
      topic = { "art", "general" },
      sharedBy = {},
      bookmarkedBy = {
        ["qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw"] = true
      },
      createdAt = 1748263888299
    },
    ["post-1748326194790-8092"] = {
      id = "post-1748326194790-8092",
      comments = {},
      upvotedBy = {},
      downvotedBy = {},
      title = "yo yo yo r2-d2",
      authorWallet = "3ggyhyhQz68ug_rpNX3hHDZid_EPPjtu0ffuC6g9kL8",
      content = "Artificial intelligence is no longer a concept of the futureâ€”it's here and now. From self-driving cars to smart assistants, AI is revolutionizing industries and enhancing our everyday experiences. This post examines the rise of AI, its current applications, and what the future may hold as machines become increasingly intelligent and autonomous.",
      topic = { "tech", "ai" },
      sharedBy = {},
      bookmarkedBy = {},
      createdAt = 1748326194790
    },
    ["post-1748278304747-9636"] = {
      id = "post-1748278304747-9636",
      comments = {},
      upvotedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      downvotedBy = {},
      title = "GM",
      authorWallet = "WNtWM-CbP4p4__4KmnVrw_k7xUcT35kuVxuXu8BMvx4",
      content = "Web3 is redefining the internet by putting power back into the hands of users. With decentralized applications and blockchain technology, individuals can own their data, participate in governance, and transact securely without intermediaries. In this post, we break down the fundamentals of Web3 and what it means for the future of the digital world.",
      topic = { "web3", "general" },
      sharedBy = {},
      bookmarkedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      createdAt = 1748278304747
    },
    ["post-1709123456-1234"] = {
      id = "post-1709123456-1234",
      comments = { "comment-1709123456-1111", "comment-1709123456-2222", "comment-1748284640507-9218", "comment-1748312339582-2244", "comment-1748319075017-8483", "comment-1748326256169-1408" },
      upvotedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg"] = true
      },
      downvotedBy = {},
      title = "First Test Article",
      authorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      content = "Welcome to the network! This is your first article on our platform. Here, you can share your thoughts, ideas, and stories with a vibrant community of readers and creators. Whether you're passionate about technology, art, science, or any other topic, this is the place to connect and grow. Start your journey today and make your voice heard!",
      topic = { "general", "web3" },
      sharedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg"] = true
      },
      bookmarkedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      createdAt = 1748263847096
    },
    ["post-1748319443108-2503"] = {
      id = "post-1748319443108-2503",
      comments = {},
      upvotedBy = {},
      downvotedBy = {},
      title = "New Test Post",
      authorWallet = "OVRxaP7mNWwjSihsr450Ah0zQwfd-LsMinVnhuapLFE",
      content = "The world is full of opportunities for those willing to explore and innovate. In this new post, we discuss the importance of curiosity, lifelong learning, and embracing change in a rapidly evolving landscape. Stay tuned for more insights and inspiration!",
      topic = { "general" },
      sharedBy = {},
      bookmarkedBy = {},
      createdAt = 1748319443108
    },
    ["post-1748284698500-2030"] = {
      id = "post-1748284698500-2030",
      comments = { "comment-1748312055996-7550", "comment-1748312376309-1866", "comment-1748319112199-2911", "comment-1748319414889-1376" },
      upvotedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw"] = true
      },
      downvotedBy = {},
      title = "Vibe Coding with BetterIDEa",
      authorWallet = "qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw",
      content = "Coding is more than just writing lines of codeâ€”it's about solving problems, building solutions, and creating value. In this post, we share tips and tricks for staying productive, motivated, and creative while coding. Whether you're a beginner or a seasoned developer, there's always something new to learn in the world of programming.",
      topic = { "tech", "coding" },
      sharedBy = {},
      bookmarkedBy = {
        ["KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true,
        ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = true
      },
      createdAt = 1748284698500
    }
}

comments = comments or {
    ["comment-1748326256169-1408"] = {
      authorWallet = "3ggyhyhQz68ug_rpNX3hHDZid_EPPjtu0ffuC6g9kL8",
      id = "comment-1748326256169-1408",
      postId = "post-1709123456-1234",
      content = "yokai",
      createdAt = 1748326256169
    },
    ["comment-1709123456-1111"] = {
      createdAt = 1748263847296,
      content = "This is a test comment",
      authorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1709123456-1111",
      postId = "post-1709123456-1234"
    },
    ["comment-1748312376309-1866"] = {
      authorWallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1748312376309-1866",
      postId = "post-1748284698500-2030",
      content = "And Vibe Check with Tokenizee ;)",
      createdAt = 1748312376309
    },
    ["comment-1709123456-2222"] = {
      createdAt = 1748263847346,
      content = "Great post!",
      authorWallet = "8iD-Gy_sKx98oth27JhjjP2V_xUSIGqs_8-skb63YHg",
      id = "comment-1709123456-2222",
      postId = "post-1709123456-1234"
    },
    ["comment-1748284640507-9218"] = {
      createdAt = 1748284640507,
      content = " made it work ",
      authorWallet = "qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw",
      id = "comment-1748284640507-9218",
      postId = "post-1709123456-1234"
    },
    ["comment-1748319414889-1376"] = {
      authorWallet = "OVRxaP7mNWwjSihsr450Ah0zQwfd-LsMinVnhuapLFE",
      id = "comment-1748319414889-1376",
      postId = "post-1748284698500-2030",
      content = "Looking great!",
      createdAt = 1748319414889
    },
    ["comment-1748282514413-2130"] = {
      createdAt = 1748282514413,
      content = " testing again ",
      authorWallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1748282514413-2130",
      postId = "post-1748263888299-9275"
    },
    ["comment-1709123456-3333"] = {
      createdAt = 1748263847396,
      content = "Nice one!",
      authorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1709123456-3333",
      postId = "post-1709123456-5678"
    },
    ["comment-1748319112199-2911"] = {
      authorWallet = "qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw",
      id = "comment-1748319112199-2911",
      postId = "post-1748284698500-2030",
      content = "tACK",
      createdAt = 1748319112199
    },
    ["comment-1748319075017-8483"] = {
      authorWallet = "qGlQRSiLM5hM2EtiLlsvMsaAj0_OfU3UzUH_1_wS-Nw",
      id = "comment-1748319075017-8483",
      postId = "post-1709123456-1234",
      content = "This article looks great!",
      createdAt = 1748319075017
    },
    ["comment-1748312339582-2244"] = {
      authorWallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1748312339582-2244",
      postId = "post-1709123456-1234",
      content = "test",
      createdAt = 1748312339582
    },
    ["comment-1748312055996-7550"] = {
      createdAt = 1748312055996,
      content = "mobile test",
      authorWallet = "KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
      id = "comment-1748312055996-7550",
      postId = "post-1748284698500-2030"
    }
}

notifications = notifications or {
    ["KkBpSPg-bFQDt2wyYUZ4dOEZyUf73ITMZcTspxIaH0s"] = {
        items = {
            {
                read = true,
                createdAt = 1748711901868,
                id = "notification-1748711901868-2927",
                actorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
                data = {
                    message = "shared your post"
                },
                type = "share",
                postId = "post-1748263888299-9275"
            },
            {
                read = true,
                id = "notification-1748765513375-1630",
                actorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
                data = {
                    message = "started following you"
                },
                type = "follow",
                createdAt = 1748765513375
            },
            {
                read = false,
                createdAt = 1748772234802,
                id = "notification-1748772234802-3728",
                actorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
                data = {
                    message = "upvoted your post"
                },
                type = "upvote",
                postId = "post-1748263888299-9275"
            },
            {
                read = false,
                createdAt = 1748711878340,
                id = "notification-1748711878340-8531",
                actorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
                data = {
                    message = "commented on your post"
                },
                type = "comment",
                postId = "post-1748263888299-9275"
            },
            {
                read = false,
                createdAt = 1748712085800,
                id = "notification-1748712085800-9824",
                actorWallet = "KkBpSPg-bFQDy3wyYUZ4dOEZyUf73ITMZcTspxIaH0s",
                data = {
                    message = "downvoted your post"
                },
                type = "downvote",
                postId = "post-1748263888299-9275"
            }
        },
        lastRead = 1748711901868
    }
}

-- Add notification types
local NOTIFICATION_TYPES = {
    FOLLOW = "follow",
    COMMENT = "comment",
    UPVOTE = "upvote",
    DOWNVOTE = "downvote",
    SHARE = "share",
    MENTION = "mention"
}

local function generateId(prefix)
    local timestamp = os.time()
    local random = math.random(1000, 9999)
    return string.format("%s-%d-%d", prefix, timestamp, random)
end

local json = require("json")

-- Add logging function at the top
local function log(level, message, data)
    local timestamp = os.date("%Y-%m-%d %H:%M:%S")
    local logMessage = string.format("[%s] [%s] %s", timestamp, level, message)
    if data then
        logMessage = logMessage .. " Data: " .. json.encode(data)
    end
    print(logMessage)
end

-- Utility Functions
local function countTableEntries(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end

local function countArrayEntries(arr)
    local count = 0
    for _ in ipairs(arr) do
        count = count + 1
    end
    return count
end

local function getAuthorDetails(wallet)
    if not users[wallet] then
        return nil
    end
    return {
        username = users[wallet].username,
        displayName = users[wallet].displayName,
        profileImageUrl = users[wallet].profileImageUrl
    }
end

local function formatPostResponse(post, requestingWallet)
    if not post then return nil end
    
    local author = getAuthorDetails(post.authorWallet)
    if not author then return nil end

    return {
        id = post.id,
        title = post.title,
        content = post.content,
        topic = post.topic,
        media = post.media or {},
        author = {
            wallet = post.authorWallet,
            username = author.username,
            displayName = author.displayName,
            profileImageUrl = author.profileImageUrl
        },
        createdAt = post.createdAt,
        comments = post.comments,
        upvotes = countTableEntries(post.upvotedBy),
        downvotes = countTableEntries(post.downvotedBy),
        shares = countTableEntries(post.sharedBy),
        bookmarks = countTableEntries(post.bookmarkedBy),
        hasUpvoted = post.upvotedBy[requestingWallet] == true,
        hasDownvoted = post.downvotedBy[requestingWallet] == true,
        hasShared = post.sharedBy[requestingWallet] == true,
        hasBookmarked = post.bookmarkedBy[requestingWallet] == true
    }
end

local function formatUserResponse(user, requestingWallet)
    if not user then return nil end

    -- Check if requesting user exists and is following the target user
    local isFollowing = false
    if users[requestingWallet] then
        isFollowing = users[requestingWallet].following[user.wallet] == true
    end

    return {
        wallet = user.wallet,
        username = user.username,
        displayName = user.displayName,
        bio = user.bio,
        profileImageUrl = user.profileImageUrl,
        backgroundImageUrl = user.backgroundImageUrl,
        dateOfBirth = user.dateOfBirth,
        createdAt = user.createdAt,
        followers = countTableEntries(user.followers),
        following = countTableEntries(user.following),
        posts = countArrayEntries(user.posts),
        comments = countArrayEntries(user.comments),
        isFollowing = isFollowing
    }
end

local function formatFollowUserResponse(follower, following, requestingWallet)
    if not follower or not following then return nil end

    return {
        follower = formatUserResponse(follower, requestingWallet),
        following = formatUserResponse(following, requestingWallet)
    }
end


-- Add notification creation function
local function createNotification(recipientWallet, type, actorWallet, postId, data)
    if not notifications[recipientWallet] then
        notifications[recipientWallet] = {
            items = {},
            lastRead = os.time()
        }
    end

    local notificationId = generateId("notification")
    local notification = {
        id = notificationId,
        type = type,
        actorWallet = actorWallet,
        postId = postId,
        data = data,
        createdAt = os.time(),
        read = false
    }

    table.insert(notifications[recipientWallet].items, notification)
    return notification
end

Handlers.add("Register", { Action = "Register" }, function(msg)
    log("INFO", "Register request received", {
        username = msg.Tags["Username"],
        displayName = msg.Tags["DisplayName"],
        wallet = msg.Tags["Wallet"]
    })

    local username = msg.Tags["Username"]
    local displayName = msg.Tags["DisplayName"]
    local dateOfBirth = msg.Tags["DateOfBirth"]
    local bio = msg.Tags["Bio"]
    local wallet = msg.Tags["Wallet"]
    local profileImageUrl = msg.Tags["ProfileImageUrl"]
    local backgroundImageUrl = msg.Tags["BackgroundImageUrl"]

    if users[wallet] then
        log("ERROR", "Register failed - Wallet already exists", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "RegisterResponse", Status = "Error" },
            Data = json.encode({ error = "Wallet already exists." })
        })
        return
    end

    for _, user in pairs(users) do
        if user.username == username then
            log("ERROR", "Register failed - Username already exists", { username = username })
            ao.send({
                Target = msg.From,
                Tags = { Action = "RegisterResponse", Status = "Error" },
                Data = json.encode({ error = "Username already exists." })
            })
            return
        end
    end

    if not username or not displayName then
        log("ERROR", "Register failed - Missing required fields", { 
            username = username, 
            displayName = displayName 
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "RegisterResponse", Status = "Error" },
            Data = json.encode({ error = "Missing required fields." })
        })
        return
    end

    local timestamp = os.time()
    users[wallet] = {
        wallet = wallet,
        username = username,
        displayName = displayName,
        dateOfBirth = dateOfBirth,
        bio = bio,
        profileImageUrl = profileImageUrl,
        backgroundImageUrl = backgroundImageUrl,
        posts = {},
        bookmarkedPosts = {},
        comments = {},
        followers = {},
        following = {},
        createdAt = timestamp
    }

    log("INFO", "User registered successfully", { 
        username = username,
        wallet = wallet
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "RegisterResponse", Status = "Success" },
        Data = json.encode({ 
            message = "User registered successfully.",
            user = formatUserResponse(users[wallet], wallet)
        })
    })
end)

--update user
Handlers.add("UpdateUser", { Action = "UpdateUser" }, function(msg)
    log("INFO", "Update user request received", {
        wallet = msg.Tags["Wallet"],
        newUsername = msg.Tags["NewUsername"]
    })

    local wallet = msg.Tags["Wallet"]
    local newUsername = msg.Tags["NewUsername"]
    local displayName = msg.Tags["DisplayName"]
    local dateOfBirth = msg.Tags["DateOfBirth"]
    local bio = msg.Tags["Bio"]
    local profileImageUrl = msg.Tags["ProfileImageUrl"]
    local backgroundImageUrl = msg.Tags["BackgroundImageUrl"]

    if not users[wallet] then
        log("ERROR", "Update failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "UpdateUserResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    if newUsername ~= users[wallet].username then
        for _, user in pairs(users) do
            if user.username == newUsername then
                log("ERROR", "Update failed - New username already exists", { 
                    newUsername = newUsername 
                })
                ao.send({
                    Target = msg.From,
                    Tags = { Action = "UpdateUserResponse", Status = "Error" },
                    Data = json.encode({ error = "New username already exists." })
                })
                return
            end
        end
    end

    users[wallet].username = newUsername
    users[wallet].displayName = displayName
    users[wallet].dateOfBirth = dateOfBirth
    users[wallet].bio = bio
    users[wallet].profileImageUrl = profileImageUrl
    users[wallet].backgroundImageUrl = backgroundImageUrl

    log("INFO", "User updated successfully", { 
        wallet = wallet,
        newUsername = newUsername
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "UpdateUserResponse", Status = "Success" },
        Data = json.encode({ 
            message = "User updated successfully.", 
            user = formatUserResponse(users[wallet], wallet)
        })
    })
end)

Handlers.add("CreatePost", { Action = "CreatePost" }, function(msg)
    log("INFO", "Create post request received", {
        wallet = msg.Tags["Wallet"],
        title = msg.Tags["Title"]
    })
    
    local wallet = msg.Tags["Wallet"]
    
    if not users[wallet] then
        log("ERROR", "Create post failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CreatePostResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    local title = msg.Tags["Title"]
    local content = msg.Tags["Content"]
    local topicJson = msg.Tags["Topic"]
    local mediaJson = msg.Tags["Media"]

    if not title or not content then
        log("ERROR", "Create post failed - Invalid post format", { 
            title = title, 
            content = content 
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CreatePostResponse", Status = "Error" },
            Data = json.encode({ error = "Invalid post format. Expected 'title: content'" })
        })
        return
    end

    -- Parse the JSON topic string into a Lua table
    local topic = {}
    local success, parsedTopic = pcall(json.decode, topicJson)
    if success and type(parsedTopic) == "table" then
        topic = parsedTopic
    else
        log("ERROR", "Create post failed - Invalid topic format", { topicJson = topicJson })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CreatePostResponse", Status = "Error" },
            Data = json.encode({ error = "Invalid topic format" })
        })
        return
    end

    -- Parse the JSON media string into a Lua table
    local media = {}
    if mediaJson then
        local success, parsedMedia = pcall(json.decode, mediaJson)
        if success and type(parsedMedia) == "table" then
            media = parsedMedia
        else
            log("ERROR", "Create post failed - Invalid media format", { mediaJson = mediaJson })
            ao.send({
                Target = msg.From,
                Tags = { Action = "CreatePostResponse", Status = "Error" },
                Data = json.encode({ error = "Invalid media format" })
            })
            return
        end
    end

    local postId = generateId("post")
    local timestamp = os.time()

    posts[postId] = {
        id = postId,
        authorWallet = wallet,
        title = title,
        content = content,
        topic = topic,
        media = media,
        upvotedBy = {},
        downvotedBy = {},
        sharedBy = {},
        bookmarkedBy = {},
        createdAt = timestamp,
        comments = {}
    }

    table.insert(users[wallet].posts, postId)

    log("INFO", "Post created successfully", { 
        postId = postId,
        wallet = wallet
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "CreatePostResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Post created successfully.",
            postId = postId,
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

Handlers.add("LoadComments", { Action = "LoadComments" }, function(msg)
    local postId = msg.Tags["PostId"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not postId then
        ao.send({
            Target = msg.From,
            Tags = { Action = "LoadCommentsResponse", Status = "Error" },
            Data = json.encode({ error = "Missing PostId tag." })
        })
        return
    end

    if not posts[postId] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "LoadCommentsResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    local commentIds = posts[postId].comments
    local commentData = {}
    
    for _, commentId in ipairs(commentIds) do
        if comments[commentId] then
            local comment = comments[commentId]
            local author = getAuthorDetails(comment.authorWallet)
            if author then
                local formattedComment = {
                    id = comment.id,
                    content = comment.content,
                    author = {
                        wallet = comment.authorWallet,
                        username = author.username,
                        displayName = author.displayName,
                        profileImageUrl = author.profileImageUrl
                    },
                    createdAt = comment.createdAt
                }
                table.insert(commentData, formattedComment)
            end
        end
    end

    -- Sort comments by creation time (newest first)
    table.sort(commentData, function(a, b)
        return a.createdAt > b.createdAt
    end)
    
    ao.send({
        Target = msg.From,
        Tags = { Action = "LoadCommentsResponse", Status = "Success" },
        Data = json.encode({ comments = commentData })
    })
end)

Handlers.add("GetFeed", { Action = "GetFeed" }, function(msg)
    local requestingWallet = msg.Tags["RequestingWallet"]
    local feed = {}

    for postId, post in pairs(posts) do
        table.insert(feed, formatPostResponse(post, requestingWallet))
    end

    -- Sort posts by creation time (newest first)
    table.sort(feed, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetFeedResponse", Status = "Success" },
        Data = json.encode({ posts = feed })
    })
end)

Handlers.add("GetTrending", { Action = "GetTrending" }, function(msg)
    local requestingWallet = msg.Tags["RequestingWallet"]
    local trending = {}

    for postId, post in pairs(posts) do
        local netScore = countArrayEntries(post.upvotedBy) - countArrayEntries(post.downvotedBy)
        local formattedPost = formatPostResponse(post, requestingWallet)
        formattedPost.netScore = netScore
        table.insert(trending, formattedPost)
    end

    -- Sort posts by net score (highest first)
    table.sort(trending, function(a, b)
        return a.netScore > b.netScore
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetTrendingResponse", Status = "Success" },
        Data = json.encode({ posts = trending })
    })
end)

Handlers.add("GetLeaderboard", { Action = "GetLeaderboard" }, function(msg)
    local requestingWallet = msg.Tags["RequestingWallet"]
    local leaderboard = {}

    for wallet, user in pairs(users) do
        local score = countArrayEntries(user.posts) + countArrayEntries(user.comments)
        table.insert(leaderboard, {
            user = formatUserResponse(user, requestingWallet),
            score = score
        })
    end

    table.sort(leaderboard, function(a, b)
        return a.score > b.score
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetLeaderboardResponse", Status = "Success" },
        Data = json.encode({ users = leaderboard })
    })
end)

Handlers.add("GetUserPosts", { Action = "GetUserPosts" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local requestingWallet = msg.Tags["RequestingWallet"]

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetUserPostsResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    local userPosts = {}
    for _, postId in ipairs(users[wallet].posts) do
        if posts[postId] then
            table.insert(userPosts, formatPostResponse(posts[postId], requestingWallet))
        end
    end

    table.sort(userPosts, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetUserPostsResponse", Status = "Success" },
        Data = json.encode({ posts = userPosts })
    })
end)

Handlers.add("GetUserComments", { Action = "GetUserComments" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetUserCommentsResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetUserCommentsResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    local userComments = {}
    for _, commentId in ipairs(users[wallet].comments) do
        if comments[commentId] then
            local comment = comments[commentId]
            local post = posts[comment.postId]
            if post then
                local author = getAuthorDetails(comment.authorWallet)
                if author then
                    local formattedComment = {
                        id = comment.id,
                        postId = comment.postId,
                        content = comment.content,
                        author = {
                            wallet = comment.authorWallet,
                            username = author.username,
                            displayName = author.displayName,
                            profileImageUrl = author.profileImageUrl
                        },
                        createdAt = comment.createdAt,
                        postTitle = post.title
                    }
                    table.insert(userComments, formattedComment)
                end
            end
        end
    end

    -- Sort comments by creation time (newest first)
    table.sort(userComments, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetUserCommentsResponse", Status = "Success" },
        Data = json.encode({ comments = userComments })
    })
end)

Handlers.add("BookmarkPost", { Action = "BookmarkPost" }, function(msg)
    log("INFO", "Bookmark post request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"],
        action = msg.Tags["BookmarkAction"]
    })

    local wallet = msg.Tags["Wallet"]
    local postId = msg.Tags["PostId"]
    local action = msg.Tags["BookmarkAction"]
    
    if not users[wallet] then
        log("ERROR", "Bookmark failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "BookmarkPostResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    if not posts[postId] then
        log("ERROR", "Bookmark failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "BookmarkPostResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if action == "add" then
        if posts[postId].bookmarkedBy[wallet] then
            log("ERROR", "Bookmark failed - Post already bookmarked", { 
                wallet = wallet,
                postId = postId 
            })
            ao.send({
                Target = msg.From,
                Tags = { Action = "BookmarkPostResponse", Status = "Error" },
                Data = json.encode({ error = "Post already bookmarked." })
            })
            return
        end
        
        posts[postId].bookmarkedBy[wallet] = true
        table.insert(users[wallet].bookmarkedPosts, postId)
        log("INFO", "Post bookmarked successfully", {
            wallet = wallet,
            postId = postId
        })
    elseif action == "remove" then
        posts[postId].bookmarkedBy[wallet] = nil
        for i, id in ipairs(users[wallet].bookmarkedPosts) do
            if id == postId then
                table.remove(users[wallet].bookmarkedPosts, i)
                break
            end
        end
        log("INFO", "Post bookmark removed successfully", {
            wallet = wallet,
            postId = postId
        })
    else
        log("ERROR", "Bookmark failed - Invalid action", { 
            action = action,
            wallet = wallet,
            postId = postId 
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "BookmarkPostResponse", Status = "Error" },
            Data = json.encode({ error = "Invalid action. Use 'add' or 'remove'." })
        })
        return
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "BookmarkPostResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Bookmark updated successfully.",
            bookmarkedPosts = users[wallet].bookmarkedPosts,
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

Handlers.add("GetPersonalizedFeed", { Action = "GetPersonalizedFeed" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetPersonalizedFeedResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetPersonalizedFeedResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    local feed = {}
    local user = users[wallet]

    -- Get posts from followed users
    for following, _ in pairs(user.following) do
        if users[following] then
            for _, postId in ipairs(users[following].posts) do
                if posts[postId] then
                    table.insert(feed, formatPostResponse(posts[postId], requestingWallet))
                end
            end
        end
    end

    -- Add user's own posts
    for _, postId in ipairs(user.posts) do
        if posts[postId] then
            table.insert(feed, formatPostResponse(posts[postId], requestingWallet))
        end
    end

    -- Sort posts by creation time (newest first)
    table.sort(feed, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetPersonalizedFeedResponse", Status = "Success" },
        Data = json.encode({ posts = feed })
    })
end)

Handlers.add("GetBookmarkedFeed", { Action = "GetBookmarkedFeed" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetBookmarkedFeedResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetBookmarkedFeedResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    local feed = {}
    local user = users[wallet]

    for _, postId in ipairs(user.bookmarkedPosts) do
        if posts[postId] then
            table.insert(feed, formatPostResponse(posts[postId], requestingWallet))
        end
    end

    -- Sort posts by creation time (newest first)
    table.sort(feed, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetBookmarkedFeedResponse", Status = "Success" },
        Data = json.encode({ posts = feed })
    })
end)

Handlers.add("GetTopicFeed", { Action = "GetTopicFeed" }, function(msg)
    local topic = msg.Tags["Topic"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not topic then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetTopicFeedResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Topic tag." })
        })
        return
    end

    local feed = {}

    for _, post in pairs(posts) do
        -- Check if the topic exists in the post's topic array
        local hasTopic = false
        for _, postTopic in ipairs(post.topic) do
            if postTopic == topic then
                hasTopic = true
                break
            end
        end
        
        if hasTopic then
            table.insert(feed, formatPostResponse(post, requestingWallet))
        end
    end

    -- Sort posts by creation time (newest first)
    table.sort(feed, function(a, b)
        return a.createdAt > b.createdAt
    end)

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetTopicFeedResponse", Status = "Success" },
        Data = json.encode({ posts = feed })
    })
end)

-- Add notification handler
Handlers.add("GetNotifications", { Action = "GetNotifications" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetNotificationsResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetNotificationsResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    -- Initialize notifications for user if not exists
    notifications[wallet] = notifications[wallet] or {
        items = {},
        lastRead = os.time()
    }

    -- Format notifications with user details
    local formattedNotifications = {}
    for _, notification in ipairs(notifications[wallet].items) do
        local formattedNotification = {
            id = notification.id,
            type = notification.type,
            createdAt = notification.createdAt,
            read = notification.read,
            data = notification.data
        }

        -- Add user details for actor
        if notification.actorWallet and users[notification.actorWallet] then
            formattedNotification.actor = {
                wallet = notification.actorWallet,
                displayName = users[notification.actorWallet].displayName,
                username = users[notification.actorWallet].username,
                profileImageUrl = users[notification.actorWallet].profileImageUrl
            }
        end

        -- Add post details if applicable
        if notification.postId and posts[notification.postId] then
            formattedNotification.post = {
                id = notification.postId,
                title = posts[notification.postId].title
            }
        end

        table.insert(formattedNotifications, formattedNotification)
    end

    -- Sort notifications by creation time (newest first)
    table.sort(formattedNotifications, function(a, b)
        return a.createdAt > b.createdAt
    end)

    -- Count unread notifications
    local unreadCount = 0
    for _, notification in ipairs(formattedNotifications) do
        if not notification.read then
            unreadCount = unreadCount + 1
        end
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetNotificationsResponse", Status = "Success" },
        Data = json.encode({
            notifications = formattedNotifications,
            unreadCount = unreadCount
        })
    })
end)

-- Add mark notifications as read handler
Handlers.add("MarkNotificationsRead", { Action = "MarkNotificationsRead" }, function(msg)
    log("INFO", "Mark notifications read request received", {
        wallet = msg.Tags["Wallet"]
    })

    local wallet = msg.Tags["Wallet"]
    
    if not wallet then
        log("ERROR", "Mark notifications read failed - Missing wallet", {})
        ao.send({
            Target = msg.From,
            Tags = { Action = "MarkNotificationsReadResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        log("ERROR", "Mark notifications read failed - User does not exist", { 
            wallet = wallet 
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "MarkNotificationsReadResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    -- Initialize notifications for user if not exists
    notifications[wallet] = notifications[wallet] or {
        items = {},
        lastRead = os.time()
    }

    -- Mark all notifications as read
    for _, notification in ipairs(notifications[wallet].items) do
        notification.read = true
    end
    notifications[wallet].lastRead = os.time()

    log("INFO", "Notifications marked as read", {
        wallet = wallet,
        count = #notifications[wallet].items
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "MarkNotificationsReadResponse", Status = "Success" },
        Data = json.encode({ message = "Notifications marked as read." })
    })
end)

-- Update FollowUser handler
Handlers.add("FollowUser", { Action = "FollowUser" }, function(msg)
    log("INFO", "Follow user request received", {
        followerWallet = msg.Tags["FollowerWallet"],
        followingWallet = msg.Tags["FollowingWallet"]
    })

    local followerWallet = msg.Tags["FollowerWallet"]
    local followingWallet = msg.Tags["FollowingWallet"]

    if not users[followerWallet] or not users[followingWallet] then
        log("ERROR", "Follow failed - User does not exist", { 
            followerWallet = followerWallet,
            followingWallet = followingWallet
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "FollowUserResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    users[followerWallet].following[followingWallet] = true
    users[followingWallet].followers[followerWallet] = true

    log("INFO", "User followed successfully", {
        followerWallet = followerWallet,
        followingWallet = followingWallet
    })

    createNotification(
        followingWallet,
        NOTIFICATION_TYPES.FOLLOW,
        followerWallet,
        nil,
        { message = "started following you" }
    )
    log("INFO", "Follow notification created", {
        recipient = followingWallet,
        actor = followerWallet
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "FollowUserResponse", Status = "Success" },
        Data = json.encode({ 
            message = "User followed successfully.",
            result = formatFollowUserResponse(users[followerWallet], users[followingWallet], followerWallet)
        })
    })
end)

-- Update CommentPost handler
Handlers.add("CommentPost", { Action = "CommentPost" }, function(msg)
    log("INFO", "Comment post request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"],
        content = msg.Tags["Content"]
    })

    local postId = msg.Tags["PostId"]
    local wallet = msg.Tags["Wallet"]
    local content = msg.Tags["Content"]
    
    if not users[wallet] then
        log("ERROR", "Comment failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CommentPostResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    if not posts[postId] then
        log("ERROR", "Comment failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CommentPostResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if not content or content == "" then
        log("ERROR", "Comment failed - Empty content", { 
            wallet = wallet,
            postId = postId 
        })
        ao.send({
            Target = msg.From,
            Tags = { Action = "CommentPostResponse", Status = "Error" },
            Data = json.encode({ error = "Comment content cannot be empty." })
        })
        return
    end

    local commentId = generateId("comment")
    local timestamp = os.time()

    comments[commentId] = {
        id = commentId,
        authorWallet = wallet,
        content = content,
        createdAt = timestamp,
        postId = postId
    }

    table.insert(posts[postId].comments, commentId)
    table.insert(users[wallet].comments, commentId)

    log("INFO", "Comment posted successfully", {
        commentId = commentId,
        wallet = wallet,
        postId = postId
    })

    if posts[postId].authorWallet ~= wallet then
        createNotification(
            posts[postId].authorWallet,
            NOTIFICATION_TYPES.COMMENT,
            wallet,
            postId,
            { message = "commented on your post" }
        )
        log("INFO", "Comment notification created", {
            recipient = posts[postId].authorWallet,
            actor = wallet,
            postId = postId
        })
    end

    -- Format comment response using the same logic as LoadComments
    local author = getAuthorDetails(wallet)
    local formattedComment = {
        id = commentId,
        content = content,
        author = {
            wallet = wallet,
            username = author.username,
            displayName = author.displayName
        },
        createdAt = timestamp,
        postId = postId
    }

    ao.send({
        Target = msg.From,
        Tags = { Action = "CommentPostResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Comment posted successfully.",
            commentId = commentId,
            comment = formattedComment
        })
    })
end)

-- Update UpvotePost handler
Handlers.add("UpvotePost", { Action = "Upvote" }, function(msg)
    log("INFO", "Upvote post request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"]
    })

    local postId = msg.Tags["PostId"]
    local wallet = msg.Tags["Wallet"]

    if not posts[postId] then
        log("ERROR", "Upvote failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "UpvoteResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if not users[wallet] then
        log("ERROR", "Upvote failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "UpvoteResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    posts[postId].downvotedBy[wallet] = nil
    posts[postId].upvotedBy[wallet] = true

    log("INFO", "Post upvoted successfully", {
        wallet = wallet,
        postId = postId
    })

    if posts[postId].authorWallet ~= wallet then
        createNotification(
            posts[postId].authorWallet,
            NOTIFICATION_TYPES.UPVOTE,
            wallet,
            postId,
            { message = "upvoted your post" }
        )
        log("INFO", "Upvote notification created", {
            recipient = posts[postId].authorWallet,
            actor = wallet,
            postId = postId
        })
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "UpvoteResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Post upvoted successfully.",
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

-- Update DownvotePost handler
Handlers.add("DownvotePost", { Action = "Downvote" }, function(msg)
    log("INFO", "Downvote post request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"]
    })

    local postId = msg.Tags["PostId"]
    local wallet = msg.Tags["Wallet"]

    if not posts[postId] then
        log("ERROR", "Downvote failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "DownvoteResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if not users[wallet] then
        log("ERROR", "Downvote failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "DownvoteResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    posts[postId].upvotedBy[wallet] = nil
    posts[postId].downvotedBy[wallet] = true

    log("INFO", "Post downvoted successfully", {
        wallet = wallet,
        postId = postId
    })

    if posts[postId].authorWallet ~= wallet then
        createNotification(
            posts[postId].authorWallet,
            NOTIFICATION_TYPES.DOWNVOTE,
            wallet,
            postId,
            { message = "downvoted your post" }
        )
        log("INFO", "Downvote notification created", {
            recipient = posts[postId].authorWallet,
            actor = wallet,
            postId = postId
        })
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "DownvoteResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Post downvoted successfully.",
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

-- Update SharePost handler
Handlers.add("SharePost", { Action = "SharePost" }, function(msg)
    log("INFO", "Share post request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"]
    })

    local postId = msg.Tags["PostId"]
    local wallet = msg.Tags["Wallet"]

    if not posts[postId] then
        log("ERROR", "Share failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "SharePostResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if not users[wallet] then
        log("ERROR", "Share failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "SharePostResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    posts[postId].sharedBy[wallet] = true

    log("INFO", "Post shared successfully", {
        wallet = wallet,
        postId = postId
    })

    if posts[postId].authorWallet ~= wallet then
        createNotification(
            posts[postId].authorWallet,
            NOTIFICATION_TYPES.SHARE,
            wallet,
            postId,
            { message = "shared your post" }
        )
        log("INFO", "Share notification created", {
            recipient = posts[postId].authorWallet,
            actor = wallet,
            postId = postId
        })
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "SharePostResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Post shared successfully.",
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

Handlers.add("GetPostStats", { Action = "GetPostStats" }, function(msg)
    local postId = msg.Tags["PostId"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not postId then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetPostStatsResponse", Status = "Error" },
            Data = json.encode({ error = "Missing PostId tag." })
        })
        return
    end

    if not posts[postId] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetPostStatsResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    local post = posts[postId]
    local stats = {
        post = formatPostResponse(post, requestingWallet),
        engagement = {
            upvotes = countTableEntries(post.upvotedBy),
            downvotes = countTableEntries(post.downvotedBy),
            shares = countTableEntries(post.sharedBy),
            bookmarks = countTableEntries(post.bookmarkedBy),
            comments = countArrayEntries(post.comments)
        },
        recentActivity = {
            comments = {},
            upvoters = {},
            downvoters = {},
            sharers = {},
            bookmarkers = {}
        }
    }

    -- Get recent comments with author details
    local recentComments = {}
    for _, commentId in ipairs(post.comments) do
        if comments[commentId] then
            table.insert(recentComments, formatCommentResponse(comments[commentId], requestingWallet))
        end
    end
    table.sort(recentComments, function(a, b) return a.createdAt > b.createdAt end)
    for i = 1, math.min(5, #recentComments) do
        table.insert(stats.recentActivity.comments, recentComments[i])
    end

    -- Get recent upvoters
    local upvoters = {}
    for wallet, _ in pairs(post.upvotedBy) do
        if users[wallet] then
            table.insert(upvoters, formatUserResponse(users[wallet], requestingWallet))
        end
    end
    for i = 1, math.min(5, #upvoters) do
        table.insert(stats.recentActivity.upvoters, upvoters[i])
    end

    -- Get recent downvoters
    local downvoters = {}
    for wallet, _ in pairs(post.downvotedBy) do
        if users[wallet] then
            table.insert(downvoters, formatUserResponse(users[wallet], requestingWallet))
        end
    end
    for i = 1, math.min(5, #downvoters) do
        table.insert(stats.recentActivity.downvoters, downvoters[i])
    end

    -- Get recent sharers
    local sharers = {}
    for wallet, _ in pairs(post.sharedBy) do
        if users[wallet] then
            table.insert(sharers, formatUserResponse(users[wallet], requestingWallet))
        end
    end
    for i = 1, math.min(5, #sharers) do
        table.insert(stats.recentActivity.sharers, sharers[i])
    end

    -- Get recent bookmarkers
    local bookmarkers = {}
    for wallet, _ in pairs(post.bookmarkedBy) do
        if users[wallet] then
            table.insert(bookmarkers, formatUserResponse(users[wallet], requestingWallet))
        end
    end
    for i = 1, math.min(5, #bookmarkers) do
        table.insert(stats.recentActivity.bookmarkers, bookmarkers[i])
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetPostStatsResponse", Status = "Success" },
        Data = json.encode(stats)
    })
end)

-- Add GetUser handler
Handlers.add("GetUser", { Action = "GetUser" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local username = msg.Tags["Username"]
    local requestingWallet = msg.Tags["RequestingWallet"]

    if not wallet and not username then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetUserResponse", Status = "Error" },
            Data = json.encode({ error = "Either Wallet or Username must be provided." })
        })
        return
    end

    local user = nil
    if wallet then
        user = users[wallet]
    else
        -- Search by username
        for _, u in pairs(users) do
            if u.username == username then
                user = u
                break
            end
        end
    end

    if not user then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetUserResponse", Status = "Error" },
            Data = json.encode({ error = "User not found." })
        })
        return
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetUserResponse", Status = "Success" },
        Data = json.encode({ user = formatUserResponse(user, requestingWallet) })
    })
end)

-- Add GetFollowersList handler
Handlers.add("GetFollowersList", { Action = "GetFollowersList" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetFollowersListResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetFollowersListResponse", Status = "Error" },
            Data = json.encode({ error = "User not found." })
        })
        return
    end

    -- Get followers list
    local followersList = {}
    for followerWallet, _ in pairs(users[wallet].followers) do
        if users[followerWallet] then
            table.insert(followersList, formatUserResponse(users[followerWallet], requestingWallet))
        end
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetFollowersListResponse", Status = "Success" },
        Data = json.encode({ users = followersList })
    })
end)

-- Add GetFollowingList handler
Handlers.add("GetFollowingList", { Action = "GetFollowingList" }, function(msg)
    local wallet = msg.Tags["Wallet"]
    local requestingWallet = msg.Tags["RequestingWallet"]
    
    if not wallet then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetFollowingListResponse", Status = "Error" },
            Data = json.encode({ error = "Missing Wallet tag." })
        })
        return
    end

    if not users[wallet] then
        ao.send({
            Target = msg.From,
            Tags = { Action = "GetFollowingListResponse", Status = "Error" },
            Data = json.encode({ error = "User not found." })
        })
        return
    end

    -- Get following list
    local followingList = {}
    for followingWallet, _ in pairs(users[wallet].following) do
        if users[followingWallet] then
            table.insert(followingList, formatUserResponse(users[followingWallet], requestingWallet))
        end
    end

    ao.send({
        Target = msg.From,
        Tags = { Action = "GetFollowingListResponse", Status = "Success" },
        Data = json.encode({ users = followingList })
    })
end)

-- Add RemoveVote handler
Handlers.add("RemoveVote", { Action = "RemoveVote" }, function(msg)
    log("INFO", "Remove vote request received", {
        wallet = msg.Tags["Wallet"],
        postId = msg.Tags["PostId"]
    })

    local postId = msg.Tags["PostId"]
    local wallet = msg.Tags["Wallet"]

    if not posts[postId] then
        log("ERROR", "Remove vote failed - Post does not exist", { postId = postId })
        ao.send({
            Target = msg.From,
            Tags = { Action = "RemoveVoteResponse", Status = "Error" },
            Data = json.encode({ error = "Post does not exist." })
        })
        return
    end

    if not users[wallet] then
        log("ERROR", "Remove vote failed - User does not exist", { wallet = wallet })
        ao.send({
            Target = msg.From,
            Tags = { Action = "RemoveVoteResponse", Status = "Error" },
            Data = json.encode({ error = "User does not exist." })
        })
        return
    end

    -- Remove both upvote and downvote if they exist
    posts[postId].upvotedBy[wallet] = nil
    posts[postId].downvotedBy[wallet] = nil

    log("INFO", "Vote removed successfully", {
        wallet = wallet,
        postId = postId
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "RemoveVoteResponse", Status = "Success" },
        Data = json.encode({ 
            message = "Vote removed successfully.",
            post = formatPostResponse(posts[postId], wallet)
        })
    })
end)

Handlers.add("Search", { Action = "Search" }, function(msg)
    log("INFO", "Search request received", {
        query = msg.Tags["Query"],
        type = msg.Tags["Type"]
    })

    local query = msg.Tags["Query"]
    local type = msg.Tags["Type"] or "all" -- all, users, posts, comments
    local requestingWallet = msg.Tags["RequestingWallet"]

    if not query or query == "" then
        log("ERROR", "Search failed - Empty query", {})
        ao.send({
            Target = msg.From,
            Tags = { Action = "SearchResponse", Status = "Error" },
            Data = json.encode({ error = "Search query cannot be empty." })
        })
        return
    end

    query = string.lower(query)
    local results = {
        users = {},
        posts = {},
        comments = {}
    }

    -- Search users
    if type == "all" or type == "users" then
        for _, user in pairs(users) do
            if string.find(string.lower(user.username), query) or 
               string.find(string.lower(user.displayName), query) or
               (user.bio and string.find(string.lower(user.bio), query)) then
                table.insert(results.users, formatUserResponse(user, requestingWallet))
            end
        end
    end

    -- Search posts
    if type == "all" or type == "posts" then
        for _, post in pairs(posts) do
            if string.find(string.lower(post.title), query) or 
               string.find(string.lower(post.content), query) then
                table.insert(results.posts, formatPostResponse(post, requestingWallet))
            end
        end
    end

    -- Search comments
    if type == "all" or type == "comments" then
        for _, comment in pairs(comments) do
            if string.find(string.lower(comment.content), query) then
                local author = getAuthorDetails(comment.authorWallet)
                if author then
                    local formattedComment = {
                        id = comment.id,
                        content = comment.content,
                        author = {
                            wallet = comment.authorWallet,
                            username = author.username,
                            displayName = author.displayName
                        },
                        createdAt = comment.createdAt,
                        postId = comment.postId
                    }
                    table.insert(results.comments, formattedComment)
                end
            end
        end
    end

    -- Sort results by relevance (exact matches first)
    local function sortByRelevance(a, b, field)
        local aLower = string.lower(a[field])
        local bLower = string.lower(b[field])
        local aExact = aLower == query
        local bExact = bLower == query
        if aExact and not bExact then return true end
        if not aExact and bExact then return false end
        return aLower < bLower
    end

    -- Sort users by username
    table.sort(results.users, function(a, b)
        return sortByRelevance(a, b, "username")
    end)

    -- Sort posts by title
    table.sort(results.posts, function(a, b)
        return sortByRelevance(a, b, "title")
    end)

    -- Sort comments by content
    table.sort(results.comments, function(a, b)
        return sortByRelevance(a, b, "content")
    end)

    log("INFO", "Search completed successfully", {
        query = query,
        type = type,
        results = {
            users = #results.users,
            posts = #results.posts,
            comments = #results.comments
        }
    })

    ao.send({
        Target = msg.From,
        Tags = { Action = "SearchResponse", Status = "Success" },
        Data = json.encode({
            query = query,
            type = type,
            results = results
        })
    })
end)